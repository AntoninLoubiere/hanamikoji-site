// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2020 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the PHP
// language.
// This file was generated by stechec2-generator. DO NOT EDIT.

#include <cstdlib>
#include <sapi/embed/php_embed.h>
#include <vector>
#include <string>


/// Les actions de jeu
typedef enum action
{
    VALIDER, ///< Valide une unique carte
    DEFAUSSER, ///< Défausse deux cartes
    CHOIX_TROIS, ///< Donne le choix entre trois cartes
    CHOIX_PAQUETS, ///< Donne le choix entre deux paquets de deux cartes
    PREMIER_JOUEUR, ///< Aucune action n'a été jouée (utilisé dans tour_precedent)
} action;

/// Enumeration contentant toutes les erreurs possibles
typedef enum error
{
    OK, ///< pas d'erreur
    ACTION_DEJA_JOUEE, ///< l'action a déjà été jouée
    CARTES_INVALIDES, ///< vous ne pouvez pas jouer ces cartes
    PAQUET_INVALIDE, ///< ce paquet n'existe pas
    GEISHA_INVALIDES, ///< cette Geisha n'existe pas (doit être un entier entre 0 et NB_GEISHA - 1)
    JOUEUR_INVALIDE, ///< ce joueur n'existe pas
    CHOIX_INVALIDE, ///< vous ne pouvez pas répondre à ce choix
    ACTION_INVALIDE, ///< vous ne pouvez pas jouer cette action maintenant
} error;

/// Enumeration représentant les différents joueurs
typedef enum joueur
{
    JOUEUR_1, ///< Le joueur 1
    JOUEUR_2, ///< Le joueur 2
    EGALITE, ///< Égalité, utilisé uniquement dans possession_geisha
} joueur;

/// La description d'une action jouée
typedef struct action_jouee
{
    action act; ///< L'action jouée
    int c1; ///< Si act==VALIDER ou act==DEFAUSSER, -1 sinon la première carte (du premier paquet)
    int c2; ///< Si act==V|D: -1 sinon la deuxième carte (du premier paquet)
    int c3; ///< Si act==V|D: -1 sinon la troisième carte (ou la première carte du second paquet si act==choix paquet)
    int c4; ///< Si act!=choix paquet: -1 sinon la deuxième carte du second paquet
} action_jouee;

extern "C" {

/// Renvoie l'identifiant du joueur
joueur api_id_joueur();

/// Renvoie l'identifiant de l'adversaire
joueur api_id_adversaire();

/// Renvoie le numéro de la manche (entre 0 et 2)
int api_manche();

/// Renvoie le numéro du tour (entre 0 et 7)
int api_tour();

/// Renvoie l'action jouée par l'adversaire
action_jouee api_tour_precedent();

/// Renvoie le nombre de cartes validées par le joueur pour la Geisha (la carte
/// validée secrètement n'est pas prise en compte)
int api_nb_cartes_validees(joueur j, int g);

/// Renvoie qui possède la Geisha
joueur api_possession_geisha(int g);

/// Renvoie si l'action a déjà été jouée par le joueur
bool api_est_jouee_action(joueur j, action a);

/// Renvoie le nombre de cartes que le joueur a
int api_nb_cartes(joueur j);

/// Renvoie les cartes que vous avez
std::vector<int> api_cartes_en_main();

/// Renvoie la carte que vous avez piochée au début du tour
int api_carte_piochee();

/// Jouer l'action valider une carte
error api_action_valider(int c);

/// Jouer l'action défausser deux cartes
error api_action_defausser(int c1, int c2);

/// Jouer l'action choisir entre trois cartes
error api_action_choix_trois(int c1, int c2, int c3);

/// Jouer l'action choisir entre deux paquets de deux cartes
error api_action_choix_paquets(int p1c1, int p1c2, int p2c1, int p2c2);

/// Choisir une des trois cartes proposées.
error api_repondre_choix_trois(int c);

/// Choisir un des deux paquets proposés.
error api_repondre_choix_paquets(int p);

/// Affiche le contenu d'une valeur de type action
void api_afficher_action(action v);

/// Affiche le contenu d'une valeur de type error
void api_afficher_error(error v);

/// Affiche le contenu d'une valeur de type joueur
void api_afficher_joueur(joueur v);

/// Affiche le contenu d'une valeur de type action_jouee
void api_afficher_action_jouee(action_jouee v);
}

template <typename PhpType, typename CxxType>
PhpType cxx_to_php(CxxType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
zval cxx_to_php<zval, int>(int in)
{
    zval x;
    ZVAL_LONG(&x, (long) in);
    return x;
}

template <>
zval cxx_to_php<zval, bool>(bool in)
{
    zval x;
    ZVAL_BOOL(&x, in);
    return x;
}

template <>
zval cxx_to_php<zval, double>(double in)
{
    zval x;
    ZVAL_DOUBLE(&x, in);
    return x;
}

template <>
zval cxx_to_php<zval, std::string>(std::string in)
{
    zval x;
    ZVAL_STRINGL(&x, in.c_str(), in.length());
    return x;
}

template <typename CxxType>
zval cxx_to_php_array(const std::vector<CxxType>& in)
{
    zval x;
    array_init(&x);

    size_t s = in.size();

    for (size_t i = 0; i < s; ++i) {
        zval tmp = cxx_to_php<zval, CxxType>(in[i]);
        add_next_index_zval(&x, &tmp);
    }

    return x;
}

template <typename PhpType, typename CxxType>
CxxType php_to_cxx(PhpType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
int php_to_cxx<zval*, int>(zval* in)
{
    if (Z_TYPE_P(in) != IS_LONG) {
        zend_error(E_WARNING, "parameter should be an int");
        throw 42;
    }
    return (int) Z_LVAL_P(in);
}

template <>
double php_to_cxx<zval*, double>(zval* in)
{
    if (Z_TYPE_P(in) != IS_DOUBLE) {
        zend_error(E_WARNING, "parameter should be a double");
        throw 42;
    }
    return (double) Z_DVAL_P(in);
}

template <>
bool php_to_cxx<zval*, bool>(zval* in)
{
    if (Z_TYPE_P(in) != IS_TRUE && Z_TYPE_P(in) != IS_FALSE) {
        zend_error(E_WARNING, "parameter should be a boolean");
        throw 42;
    }
    return (bool) (Z_TYPE_P(in) == IS_TRUE);
}

template <>
std::string php_to_cxx<zval*, std::string>(zval* in)
{
    if (Z_TYPE_P(in) != IS_STRING) {
        zend_error(E_WARNING, "parameter should be a string");
        throw 42;
    }
    return Z_STRVAL_P(in);
}

template <typename CxxType>
std::vector<CxxType> php_to_cxx_array(zval* in)
{
    if (Z_TYPE_P(in) != IS_ARRAY) {
        zend_error(E_WARNING, "parameter should be an array");
        throw 42;
    }

    HashTable* ht = Z_ARRVAL_P(in);
    std::vector<CxxType> out;
    size_t s = zend_hash_num_elements(ht);

    for (size_t i = 0; i < s; ++i)
    {
        zval* v = zend_hash_index_find(ht, i);
        out.push_back(php_to_cxx<zval*, CxxType>(v));
    }

    return out;
}

// Les actions de jeu

template <>
zval cxx_to_php<zval, action>(action in)
{
    return cxx_to_php<zval, int>((int) in);
}

template <>
action php_to_cxx<zval*, action>(zval* in)
{
    return (action) php_to_cxx<zval*, int>(in);
}

// Enumeration contentant toutes les erreurs possibles

template <>
zval cxx_to_php<zval, error>(error in)
{
    return cxx_to_php<zval, int>((int) in);
}

template <>
error php_to_cxx<zval*, error>(zval* in)
{
    return (error) php_to_cxx<zval*, int>(in);
}

// Enumeration représentant les différents joueurs

template <>
zval cxx_to_php<zval, joueur>(joueur in)
{
    return cxx_to_php<zval, int>((int) in);
}

template <>
joueur php_to_cxx<zval*, joueur>(zval* in)
{
    return (joueur) php_to_cxx<zval*, int>(in);
}

// La description d'une action jouée

template <>
zval cxx_to_php<zval, action_jouee>(action_jouee in)
{
    zval ret;
    zval tmp;
    array_init(&ret);

    // act
    tmp = cxx_to_php<zval, action>(in.act);
    add_assoc_zval(&ret, "act", &tmp);

    // c1
    tmp = cxx_to_php<zval, int>(in.c1);
    add_assoc_zval(&ret, "c1", &tmp);

    // c2
    tmp = cxx_to_php<zval, int>(in.c2);
    add_assoc_zval(&ret, "c2", &tmp);

    // c3
    tmp = cxx_to_php<zval, int>(in.c3);
    add_assoc_zval(&ret, "c3", &tmp);

    // c4
    tmp = cxx_to_php<zval, int>(in.c4);
    add_assoc_zval(&ret, "c4", &tmp);

    return ret;
}

template <>
action_jouee php_to_cxx<zval*, action_jouee>(zval* in)
{
    action_jouee out;
    if (Z_TYPE_P(in) != IS_ARRAY) {
        zend_error(E_WARNING, "parameter is not a structure");
        throw 42;
    }
    HashTable* ht = Z_ARRVAL_P(in);
    zval* tmp = NULL;

    // act
    tmp = zend_hash_str_find(ht, "act", 3);
    if (tmp == NULL) {
        zend_error(E_WARNING,
            "field \"act\" of struct "
            "\"action_jouee\" not found");
        throw 42;
    }
    out.act = php_to_cxx<zval*, action>(tmp);

    // c1
    tmp = zend_hash_str_find(ht, "c1", 2);
    if (tmp == NULL) {
        zend_error(E_WARNING,
            "field \"c1\" of struct "
            "\"action_jouee\" not found");
        throw 42;
    }
    out.c1 = php_to_cxx<zval*, int>(tmp);

    // c2
    tmp = zend_hash_str_find(ht, "c2", 2);
    if (tmp == NULL) {
        zend_error(E_WARNING,
            "field \"c2\" of struct "
            "\"action_jouee\" not found");
        throw 42;
    }
    out.c2 = php_to_cxx<zval*, int>(tmp);

    // c3
    tmp = zend_hash_str_find(ht, "c3", 2);
    if (tmp == NULL) {
        zend_error(E_WARNING,
            "field \"c3\" of struct "
            "\"action_jouee\" not found");
        throw 42;
    }
    out.c3 = php_to_cxx<zval*, int>(tmp);

    // c4
    tmp = zend_hash_str_find(ht, "c4", 2);
    if (tmp == NULL) {
        zend_error(E_WARNING,
            "field \"c4\" of struct "
            "\"action_jouee\" not found");
        throw 42;
    }
    out.c4 = php_to_cxx<zval*, int>(tmp);

    return out;
}


// Renvoie l'identifiant du joueur
PHP_FUNCTION(php_api_id_joueur)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php<zval, joueur>(api_id_joueur());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_id_joueur, 0, 0, 0)
ZEND_END_ARG_INFO()

// Renvoie l'identifiant de l'adversaire
PHP_FUNCTION(php_api_id_adversaire)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php<zval, joueur>(api_id_adversaire());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_id_adversaire, 0, 0, 0)
ZEND_END_ARG_INFO()

// Renvoie le numéro de la manche (entre 0 et 2)
PHP_FUNCTION(php_api_manche)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php<zval, int>(api_manche());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_manche, 0, 0, 0)
ZEND_END_ARG_INFO()

// Renvoie le numéro du tour (entre 0 et 7)
PHP_FUNCTION(php_api_tour)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php<zval, int>(api_tour());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_tour, 0, 0, 0)
ZEND_END_ARG_INFO()

// Renvoie l'action jouée par l'adversaire
PHP_FUNCTION(php_api_tour_precedent)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php<zval, action_jouee>(api_tour_precedent());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_tour_precedent, 0, 0, 0)
ZEND_END_ARG_INFO()

// Renvoie le nombre de cartes validées par le joueur pour la Geisha (la carte
// validée secrètement n'est pas prise en compte)
PHP_FUNCTION(php_api_nb_cartes_validees)
{
    (void) execute_data;
    zval* arg_j;
    zval* arg_g;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "zz", &arg_j, &arg_g) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, int>(api_nb_cartes_validees(php_to_cxx<zval*, joueur>(arg_j), php_to_cxx<zval*, int>(arg_g)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_nb_cartes_validees, 0, 0, 2)
    ZEND_ARG_INFO(0, j)
    ZEND_ARG_INFO(0, g)
ZEND_END_ARG_INFO()

// Renvoie qui possède la Geisha
PHP_FUNCTION(php_api_possession_geisha)
{
    (void) execute_data;
    zval* arg_g;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_g) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, joueur>(api_possession_geisha(php_to_cxx<zval*, int>(arg_g)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_possession_geisha, 0, 0, 1)
    ZEND_ARG_INFO(0, g)
ZEND_END_ARG_INFO()

// Renvoie si l'action a déjà été jouée par le joueur
PHP_FUNCTION(php_api_est_jouee_action)
{
    (void) execute_data;
    zval* arg_j;
    zval* arg_a;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "zz", &arg_j, &arg_a) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, bool>(api_est_jouee_action(php_to_cxx<zval*, joueur>(arg_j), php_to_cxx<zval*, action>(arg_a)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_est_jouee_action, 0, 0, 2)
    ZEND_ARG_INFO(0, j)
    ZEND_ARG_INFO(0, a)
ZEND_END_ARG_INFO()

// Renvoie le nombre de cartes que le joueur a
PHP_FUNCTION(php_api_nb_cartes)
{
    (void) execute_data;
    zval* arg_j;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_j) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, int>(api_nb_cartes(php_to_cxx<zval*, joueur>(arg_j)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_nb_cartes, 0, 0, 1)
    ZEND_ARG_INFO(0, j)
ZEND_END_ARG_INFO()

// Renvoie les cartes que vous avez
PHP_FUNCTION(php_api_cartes_en_main)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php_array(api_cartes_en_main());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_cartes_en_main, 0, 0, 0)
ZEND_END_ARG_INFO()

// Renvoie la carte que vous avez piochée au début du tour
PHP_FUNCTION(php_api_carte_piochee)
{
    (void) execute_data;
    try {
        zval ret = cxx_to_php<zval, int>(api_carte_piochee());
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_carte_piochee, 0, 0, 0)
ZEND_END_ARG_INFO()

// Jouer l'action valider une carte
PHP_FUNCTION(php_api_action_valider)
{
    (void) execute_data;
    zval* arg_c;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_c) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, error>(api_action_valider(php_to_cxx<zval*, int>(arg_c)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_action_valider, 0, 0, 1)
    ZEND_ARG_INFO(0, c)
ZEND_END_ARG_INFO()

// Jouer l'action défausser deux cartes
PHP_FUNCTION(php_api_action_defausser)
{
    (void) execute_data;
    zval* arg_c1;
    zval* arg_c2;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "zz", &arg_c1, &arg_c2) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, error>(api_action_defausser(php_to_cxx<zval*, int>(arg_c1), php_to_cxx<zval*, int>(arg_c2)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_action_defausser, 0, 0, 2)
    ZEND_ARG_INFO(0, c1)
    ZEND_ARG_INFO(0, c2)
ZEND_END_ARG_INFO()

// Jouer l'action choisir entre trois cartes
PHP_FUNCTION(php_api_action_choix_trois)
{
    (void) execute_data;
    zval* arg_c1;
    zval* arg_c2;
    zval* arg_c3;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "zzz", &arg_c1, &arg_c2, &arg_c3) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, error>(api_action_choix_trois(php_to_cxx<zval*, int>(arg_c1), php_to_cxx<zval*, int>(arg_c2), php_to_cxx<zval*, int>(arg_c3)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_action_choix_trois, 0, 0, 3)
    ZEND_ARG_INFO(0, c1)
    ZEND_ARG_INFO(0, c2)
    ZEND_ARG_INFO(0, c3)
ZEND_END_ARG_INFO()

// Jouer l'action choisir entre deux paquets de deux cartes
PHP_FUNCTION(php_api_action_choix_paquets)
{
    (void) execute_data;
    zval* arg_p1c1;
    zval* arg_p1c2;
    zval* arg_p2c1;
    zval* arg_p2c2;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "zzzz", &arg_p1c1, &arg_p1c2, &arg_p2c1, &arg_p2c2) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, error>(api_action_choix_paquets(php_to_cxx<zval*, int>(arg_p1c1), php_to_cxx<zval*, int>(arg_p1c2), php_to_cxx<zval*, int>(arg_p2c1), php_to_cxx<zval*, int>(arg_p2c2)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_action_choix_paquets, 0, 0, 4)
    ZEND_ARG_INFO(0, p1c1)
    ZEND_ARG_INFO(0, p1c2)
    ZEND_ARG_INFO(0, p2c1)
    ZEND_ARG_INFO(0, p2c2)
ZEND_END_ARG_INFO()

// Choisir une des trois cartes proposées.
PHP_FUNCTION(php_api_repondre_choix_trois)
{
    (void) execute_data;
    zval* arg_c;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_c) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, error>(api_repondre_choix_trois(php_to_cxx<zval*, int>(arg_c)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_repondre_choix_trois, 0, 0, 1)
    ZEND_ARG_INFO(0, c)
ZEND_END_ARG_INFO()

// Choisir un des deux paquets proposés.
PHP_FUNCTION(php_api_repondre_choix_paquets)
{
    (void) execute_data;
    zval* arg_p;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_p) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        zval ret = cxx_to_php<zval, error>(api_repondre_choix_paquets(php_to_cxx<zval*, int>(arg_p)));
        RETURN_ZVAL(&ret, 0, 0);
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_repondre_choix_paquets, 0, 0, 1)
    ZEND_ARG_INFO(0, p)
ZEND_END_ARG_INFO()

// Affiche le contenu d'une valeur de type action
PHP_FUNCTION(php_api_afficher_action)
{
    (void) execute_data;
    zval* arg_v;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_v) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        (api_afficher_action(php_to_cxx<zval*, action>(arg_v)));
        RETURN_NULL();
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_afficher_action, 0, 0, 1)
    ZEND_ARG_INFO(0, v)
ZEND_END_ARG_INFO()

// Affiche le contenu d'une valeur de type error
PHP_FUNCTION(php_api_afficher_error)
{
    (void) execute_data;
    zval* arg_v;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_v) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        (api_afficher_error(php_to_cxx<zval*, error>(arg_v)));
        RETURN_NULL();
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_afficher_error, 0, 0, 1)
    ZEND_ARG_INFO(0, v)
ZEND_END_ARG_INFO()

// Affiche le contenu d'une valeur de type joueur
PHP_FUNCTION(php_api_afficher_joueur)
{
    (void) execute_data;
    zval* arg_v;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_v) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        (api_afficher_joueur(php_to_cxx<zval*, joueur>(arg_v)));
        RETURN_NULL();
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_afficher_joueur, 0, 0, 1)
    ZEND_ARG_INFO(0, v)
ZEND_END_ARG_INFO()

// Affiche le contenu d'une valeur de type action_jouee
PHP_FUNCTION(php_api_afficher_action_jouee)
{
    (void) execute_data;
    zval* arg_v;

    if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &arg_v) == FAILURE)
    {
        RETURN_NULL();
    }

    try {
        (api_afficher_action_jouee(php_to_cxx<zval*, action_jouee>(arg_v)));
        RETURN_NULL();
    } catch (...) {
        RETURN_NULL();
    }
}

ZEND_BEGIN_ARG_INFO_EX(php_arginfo_afficher_action_jouee, 0, 0, 1)
    ZEND_ARG_INFO(0, v)
ZEND_END_ARG_INFO()

// API function to register.
static zend_function_entry api_callback[] = {
    PHP_FALIAS(id_joueur, php_api_id_joueur, php_arginfo_id_joueur)
    PHP_FALIAS(id_adversaire, php_api_id_adversaire, php_arginfo_id_adversaire)
    PHP_FALIAS(manche, php_api_manche, php_arginfo_manche)
    PHP_FALIAS(tour, php_api_tour, php_arginfo_tour)
    PHP_FALIAS(tour_precedent, php_api_tour_precedent, php_arginfo_tour_precedent)
    PHP_FALIAS(nb_cartes_validees, php_api_nb_cartes_validees, php_arginfo_nb_cartes_validees)
    PHP_FALIAS(possession_geisha, php_api_possession_geisha, php_arginfo_possession_geisha)
    PHP_FALIAS(est_jouee_action, php_api_est_jouee_action, php_arginfo_est_jouee_action)
    PHP_FALIAS(nb_cartes, php_api_nb_cartes, php_arginfo_nb_cartes)
    PHP_FALIAS(cartes_en_main, php_api_cartes_en_main, php_arginfo_cartes_en_main)
    PHP_FALIAS(carte_piochee, php_api_carte_piochee, php_arginfo_carte_piochee)
    PHP_FALIAS(action_valider, php_api_action_valider, php_arginfo_action_valider)
    PHP_FALIAS(action_defausser, php_api_action_defausser, php_arginfo_action_defausser)
    PHP_FALIAS(action_choix_trois, php_api_action_choix_trois, php_arginfo_action_choix_trois)
    PHP_FALIAS(action_choix_paquets, php_api_action_choix_paquets, php_arginfo_action_choix_paquets)
    PHP_FALIAS(repondre_choix_trois, php_api_repondre_choix_trois, php_arginfo_repondre_choix_trois)
    PHP_FALIAS(repondre_choix_paquets, php_api_repondre_choix_paquets, php_arginfo_repondre_choix_paquets)
    PHP_FALIAS(afficher_action, php_api_afficher_action, php_arginfo_afficher_action)
    PHP_FALIAS(afficher_error, php_api_afficher_error, php_arginfo_afficher_error)
    PHP_FALIAS(afficher_joueur, php_api_afficher_joueur, php_arginfo_afficher_joueur)
    PHP_FALIAS(afficher_action_jouee, php_api_afficher_action_jouee, php_arginfo_afficher_action_jouee)
    {NULL, NULL, NULL, 0, 0}
};

static zend_module_entry api_module_entry = {
    STANDARD_MODULE_HEADER,
    "api",
    api_callback,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    "1.0",
    STANDARD_MODULE_PROPERTIES
};

static void ini_set(const std::string& key, const std::string& value)
{
    zend_string* ini_entry = zend_string_init(key.c_str(), key.size(), 0);
    zend_alter_ini_entry_chars(
            ini_entry, value.c_str(), value.size(),
            PHP_INI_SYSTEM, PHP_INI_STAGE_STARTUP
    );
    zend_string_release(ini_entry);
}

static void _init_php()
{
    static int initialized = 0;
    if (initialized)
        return;
    initialized = 1;

    const char* path;
    path = getenv("CHAMPION_PATH");
    if (!path)
        path = ".";

    char buffer[1024];
    snprintf(buffer, 1024, "include('%s/%s.php');", path, "champion");

    char champion_name[] = "champion";
    char* argv[] = { champion_name, NULL };
    php_embed_init(1, argv);

    ini_set("zend.assertions", "1");
    ini_set("assert.exception", "1");

    zend_startup_module(&api_module_entry);

    char string_name[] = "PHP to Stechec interface";
    zend_eval_string(buffer, NULL, string_name);
}


// Functions called from Stechec to PHP

extern "C" void init_jeu()
{
    zval ret;
    zval fname;
    _init_php();

    ZVAL_STRING(&fname, "init_jeu");

    if (call_user_function(EG(function_table), NULL, &fname, &ret, 0, NULL) == FAILURE)
        abort();

}

extern "C" void jouer_tour()
{
    zval ret;
    zval fname;
    _init_php();

    ZVAL_STRING(&fname, "jouer_tour");

    if (call_user_function(EG(function_table), NULL, &fname, &ret, 0, NULL) == FAILURE)
        abort();

}

extern "C" void repondre_action_choix_trois()
{
    zval ret;
    zval fname;
    _init_php();

    ZVAL_STRING(&fname, "repondre_action_choix_trois");

    if (call_user_function(EG(function_table), NULL, &fname, &ret, 0, NULL) == FAILURE)
        abort();

}

extern "C" void repondre_action_choix_paquets()
{
    zval ret;
    zval fname;
    _init_php();

    ZVAL_STRING(&fname, "repondre_action_choix_paquets");

    if (call_user_function(EG(function_table), NULL, &fname, &ret, 0, NULL) == FAILURE)
        abort();

}

extern "C" void fin_jeu()
{
    zval ret;
    zval fname;
    _init_php();

    ZVAL_STRING(&fname, "fin_jeu");

    if (call_user_function(EG(function_table), NULL, &fname, &ret, 0, NULL) == FAILURE)
        abort();

}
