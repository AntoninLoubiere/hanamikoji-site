// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2005-2020 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the Java language.
// This file was generated by stechec2-generator. DO NOT EDIT.

#include <cstdlib>
#include <string>
#include <vector>

#include <jni.h>

struct Champion
{
    static jclass Class();
};

/// Les actions de jeu
typedef enum action
{
    VALIDER, ///< Valide une unique carte
    DEFAUSSER, ///< Defausse deux cartes
    CHOIX_TROIS, ///< Donne le choix entre trois cartes
    CHOIX_PAQUETS, ///< Donne le choix entre deux paquets de deux cartes
    PREMIER_JOUEUR, ///< Aucune action n'a été jouée (utilisé dans tour_precedent)
} action;

struct Action
{
    static jclass Class();
};

/// Enumeration contentant toutes les erreurs possibles
typedef enum error
{
    OK, ///< pas d'erreur
    ACTION_DEJA_JOUEE, ///< l'action a déjà été jouée
    CARTES_INVALIDES, ///< vous ne pouvez pas jouer ces cartes
    PAQUET_INVALIDE, ///< ce paquet n'existe pas
    GEISHA_INVALIDES, ///< cette geisha n'existe pas (doit être un entier entre 0 et NB_GEISHA)
    JOUEUR_INVALIDE, ///< ce joueur n'existe pas
    CHOIX_INVALIDE, ///< vous ne pouvez pas repondre à ce choix
    ACTION_INVALIDE, ///< vous ne pouvez pas jouer cette action maintenant
} error;

struct Error
{
    static jclass Class();
};

/// Enumeration représentant les différents joueurs
typedef enum joueur
{
    JOUEUR_1, ///< Le joueur 1
    JOUEUR_2, ///< Le joueur 2
    EGALITE, ///< Égalité, utilisé uniquement dans possession_geisha
} joueur;

struct Joueur
{
    static jclass Class();
};

/// La description d'une action jouée
typedef struct action_jouee
{
    action act; ///< L'action jouée
    int c1; ///< Si act==VALIDER ou act==DEFAUSSER, -1 sinon la première carte (du premier paquet)
    int c2; ///< Si act==V|D: -1 sinon la deuxième carte (du premier paquet)
    int c3; ///< Si act==V|D: -1 sinon la troisième carte (ou la première carte du second paquet si act==choix paquet)
    int c4; ///< Si act!=choix paquet: -1 sinon la deuxième carte du second paquet
} action_jouee;

struct ActionJouee
{
    static jclass Class();
};

struct StechecJavaRunTime
{
    StechecJavaRunTime() = default;
    ~StechecJavaRunTime();
    void init();
    bool function_enter();
    void function_exit(bool attached);

    JavaVM* jvm;
    JNIEnv* env;
    jobject prologin;

private:
    bool is_init_ = false;
};
static struct StechecJavaRunTime jrt;

extern "C" joueur api_id_joueur();
extern "C" joueur api_id_adversaire();
extern "C" int api_manche();
extern "C" int api_tour();
extern "C" action_jouee api_tour_precedent();
extern "C" int api_nb_carte_validee(joueur j, int g);
extern "C" joueur api_possession_geisha(int g);
extern "C" bool api_est_jouee_action(joueur j, action a);
extern "C" int api_nb_cartes(joueur j);
extern "C" std::vector<int> api_cartes_en_main();
extern "C" int api_carte_pioche();
extern "C" error api_action_valider(int c);
extern "C" error api_action_defausser(int c1, int c2);
extern "C" error api_action_choix_trois(int c1, int c2, int c3);
extern "C" error api_action_choix_paquets(int p1c1, int p1c2, int p2c1, int p2c2);
extern "C" error api_repondre_choix_trois(int c);
extern "C" error api_repondre_choix_paquets(int p);
extern "C" void api_afficher_action(action v);
extern "C" void api_afficher_error(error v);
extern "C" void api_afficher_joueur(joueur v);
extern "C" void api_afficher_action_jouee(action_jouee v);


// In case of errors...
template <typename Lang, typename CxxType>
CxxType java_to_cxx(Lang in)
{
    return in.error_should_not_happen;
}

template <typename CxxType, typename Lang>
Lang cxx_to_java(CxxType in)
{
    return in.error_should_not_happen;
}

template<typename Lang, typename CxxType>
std::vector<CxxType> java_to_cxx_array(jobject in);

template<typename CxxType, typename Lang>
jarray cxx_to_java_array(std::vector<CxxType> in);

// Basic type wrappers
template <>
jboolean cxx_to_java<bool, jboolean>(bool in)
{
    return (jboolean)in;
}

template <>
bool java_to_cxx<jboolean, bool>(jboolean in)
{
    return (bool)in;
}

template <>
jarray cxx_to_java_array<bool, jboolean>(std::vector<bool> in)
{
    jbooleanArray out = jrt.env->NewBooleanArray((jsize)in.size());
    // std::vector<bool>::data() does not return a bool*, because the data is
    // packed, so we need to create a new bool array
    jboolean* in_cast = new jboolean[in.size()];
    std::copy(std::begin(in), std::end(in), in_cast);
    jrt.env->SetBooleanArrayRegion(out, (jsize)0, (jsize)in.size(), in_cast);
    delete[] in_cast;
    return (jarray)out;
}

template <>
std::vector<bool> java_to_cxx_array<jboolean, bool>(jobject in)
{
    jbooleanArray array = (jbooleanArray)in;
    jsize size = jrt.env->GetArrayLength(array);
    jboolean* datas = jrt.env->GetBooleanArrayElements(array, NULL);
    std::vector<bool> out(datas, datas + size);
    jrt.env->ReleaseBooleanArrayElements(array, datas, JNI_ABORT);
    return out;
}

template <>
jint cxx_to_java<int, jint>(int in)
{
    return (jint)in;
}

template <>
int java_to_cxx<jint, int>(jint in)
{
    return (int)in;
}

template <>
jarray cxx_to_java_array<int, jint>(std::vector<int> in)
{
    jintArray out = jrt.env->NewIntArray((jsize)in.size());
    const jint* in_cast = (const jint*)in.data();
    jrt.env->SetIntArrayRegion(out, (jsize)0, (jsize)in.size(), in_cast);
    return (jarray)out;
}

template <>
std::vector<int> java_to_cxx_array<jint, int>(jobject in)
{
    jintArray array = (jintArray)in;
    jsize size = jrt.env->GetArrayLength(array);
    jint* datas = jrt.env->GetIntArrayElements(array, NULL);
    std::vector<int> out(datas, datas + size);
    jrt.env->ReleaseIntArrayElements(array, datas, JNI_ABORT);
    return out;
}

template <>
jdouble cxx_to_java<double, jdouble>(double in)
{
    return (jdouble)in;
}

template <>
double java_to_cxx<jdouble, double>(jdouble in)
{
    return (double)in;
}

template <>
jarray cxx_to_java_array<double, jdouble>(std::vector<double> in)
{
    jdoubleArray out = jrt.env->NewDoubleArray((jsize)in.size());
    const jdouble* in_cast = (const jdouble*)in.data();
    jrt.env->SetDoubleArrayRegion(out, (jsize)0, (jsize)in.size(), in_cast);
    return (jarray)out;
}

template <>
std::vector<double> java_to_cxx_array<jdouble, double>(jobject in)
{
    jdoubleArray array = (jdoubleArray)in;
    jsize size = jrt.env->GetArrayLength(array);
    jdouble* datas = jrt.env->GetDoubleArrayElements(array, NULL);
    std::vector<double> out(datas, datas + size);
    jrt.env->ReleaseDoubleArrayElements(array, datas, JNI_ABORT);
    return out;
}

// String wrappers
template <>
jstring cxx_to_java<std::string, jstring>(std::string in)
{
    return jrt.env->NewStringUTF(in.data());
}

template <>
std::string java_to_cxx<jstring, std::string>(jstring in)
{
    jboolean is_copy;
    const char* datas = jrt.env->GetStringUTFChars(in, &is_copy);
    jsize size = jrt.env->GetStringLength(in);
    std::string out(datas, (size_t)size);
    if (is_copy)
        jrt.env->ReleaseStringUTFChars(in, datas);
    return out;
}

template <>
jarray cxx_to_java_array<std::string, jstring>(std::vector<std::string> in)
{
    jobjectArray out = jrt.env->NewObjectArray(
            (jsize)in.size(), jrt.env->FindClass("java/lang/String"), NULL);
    for (size_t i = 0; i < in.size(); i++)
        jrt.env->SetObjectArrayElement(out, (jsize)i, cxx_to_java<std::string, jstring>(in[i]));
    return out;
}

template <>
std::vector<std::string> java_to_cxx_array<jstring, std::string>(jobject in)
{
    jobjectArray array = (jobjectArray)in;
    size_t size = (size_t)jrt.env->GetArrayLength(array);
    std::vector<std::string> out;
    for (size_t i = 0; i < size; i++)
        out.push_back(java_to_cxx<jstring, std::string>(
            (jstring)jrt.env->GetObjectArrayElement(array, (jsize)i)));
    return out;
}

// Object array wrappers (assume Lang::class exists)
template <typename CxxType, typename Lang>
jarray cxx_to_java_array(std::vector<CxxType> in)
{
    jobjectArray out = jrt.env->NewObjectArray(
            (jsize)in.size(), Lang::Class(), NULL);
    for (size_t i = 0; i < in.size(); i++)
        jrt.env->SetObjectArrayElement(out, (jsize)i, cxx_to_java<CxxType, jobject>(in[i]));
    return out;
}

template <typename Lang, typename CxxType>
std::vector<CxxType> java_to_cxx_array(jobject in)
{
    jobjectArray array = (jobjectArray)in;
    size_t size = (size_t)jrt.env->GetArrayLength(array);
    std::vector<CxxType> out;
    for (size_t i = 0; i < size; i++)
        out.push_back(java_to_cxx<jobject, CxxType>(jrt.env->GetObjectArrayElement(array, (jsize)i)));
    return out;
}

template<>
action java_to_cxx<jobject, action>(jobject in)
{
    jmethodID ordinal = jrt.env->GetMethodID(Action::Class(), "ordinal", "()I");
    return action(java_to_cxx<jint, int>(jrt.env->CallIntMethod(in, ordinal)));
}

template<>
jobject cxx_to_java<action, jobject>(action in)
{
    jmethodID method = jrt.env->GetStaticMethodID(Action::Class(), "values", "()[LAction;");
    jobjectArray values = (jobjectArray)jrt.env->CallStaticObjectMethod(Action::Class(), method);
    return jrt.env->GetObjectArrayElement(values, (jsize)in);
}

template<>
error java_to_cxx<jobject, error>(jobject in)
{
    jmethodID ordinal = jrt.env->GetMethodID(Error::Class(), "ordinal", "()I");
    return error(java_to_cxx<jint, int>(jrt.env->CallIntMethod(in, ordinal)));
}

template<>
jobject cxx_to_java<error, jobject>(error in)
{
    jmethodID method = jrt.env->GetStaticMethodID(Error::Class(), "values", "()[LError;");
    jobjectArray values = (jobjectArray)jrt.env->CallStaticObjectMethod(Error::Class(), method);
    return jrt.env->GetObjectArrayElement(values, (jsize)in);
}

template<>
joueur java_to_cxx<jobject, joueur>(jobject in)
{
    jmethodID ordinal = jrt.env->GetMethodID(Joueur::Class(), "ordinal", "()I");
    return joueur(java_to_cxx<jint, int>(jrt.env->CallIntMethod(in, ordinal)));
}

template<>
jobject cxx_to_java<joueur, jobject>(joueur in)
{
    jmethodID method = jrt.env->GetStaticMethodID(Joueur::Class(), "values", "()[LJoueur;");
    jobjectArray values = (jobjectArray)jrt.env->CallStaticObjectMethod(Joueur::Class(), method);
    return jrt.env->GetObjectArrayElement(values, (jsize)in);
}

template <>
action_jouee java_to_cxx<jobject, action_jouee>(jobject in)
{
    action_jouee out;
    out.act = java_to_cxx<jobject, action>(jrt.env->GetObjectField(in, jrt.env->GetFieldID(ActionJouee::Class(), "act", "LAction;")));
    out.c1 = java_to_cxx<jint, int>(jrt.env->GetIntField(in, jrt.env->GetFieldID(ActionJouee::Class(), "c1", "I")));
    out.c2 = java_to_cxx<jint, int>(jrt.env->GetIntField(in, jrt.env->GetFieldID(ActionJouee::Class(), "c2", "I")));
    out.c3 = java_to_cxx<jint, int>(jrt.env->GetIntField(in, jrt.env->GetFieldID(ActionJouee::Class(), "c3", "I")));
    out.c4 = java_to_cxx<jint, int>(jrt.env->GetIntField(in, jrt.env->GetFieldID(ActionJouee::Class(), "c4", "I")));
    return out;
}

template <>
jobject cxx_to_java<action_jouee, jobject>(action_jouee in)
{
    jobject out = jrt.env->NewObject(ActionJouee::Class(), jrt.env->GetMethodID(ActionJouee::Class(), "<init>", "()V"));
    jrt.env->SetObjectField(out, jrt.env->GetFieldID(ActionJouee::Class(), "act", "LAction;"), cxx_to_java<action, jobject>(in.act));
    jrt.env->SetIntField(out, jrt.env->GetFieldID(ActionJouee::Class(), "c1", "I"), cxx_to_java<int, jint>(in.c1));
    jrt.env->SetIntField(out, jrt.env->GetFieldID(ActionJouee::Class(), "c2", "I"), cxx_to_java<int, jint>(in.c2));
    jrt.env->SetIntField(out, jrt.env->GetFieldID(ActionJouee::Class(), "c3", "I"), cxx_to_java<int, jint>(in.c3));
    jrt.env->SetIntField(out, jrt.env->GetFieldID(ActionJouee::Class(), "c4", "I"), cxx_to_java<int, jint>(in.c4));
    return out;
}

jobject id_joueur(JNIEnv*, jobject)
{
    return cxx_to_java<joueur, jobject>(api_id_joueur());
}

jobject id_adversaire(JNIEnv*, jobject)
{
    return cxx_to_java<joueur, jobject>(api_id_adversaire());
}

jint manche(JNIEnv*, jobject)
{
    return cxx_to_java<int, jint>(api_manche());
}

jint tour(JNIEnv*, jobject)
{
    return cxx_to_java<int, jint>(api_tour());
}

jobject tour_precedent(JNIEnv*, jobject)
{
    return cxx_to_java<action_jouee, jobject>(api_tour_precedent());
}

jint nb_carte_validee(JNIEnv*, jobject, jobject j, jint g)
{
    return cxx_to_java<int, jint>(api_nb_carte_validee(java_to_cxx<jobject, joueur>(j), java_to_cxx<jint, int>(g)));
}

jobject possession_geisha(JNIEnv*, jobject, jint g)
{
    return cxx_to_java<joueur, jobject>(api_possession_geisha(java_to_cxx<jint, int>(g)));
}

jboolean est_jouee_action(JNIEnv*, jobject, jobject j, jobject a)
{
    return cxx_to_java<bool, jboolean>(api_est_jouee_action(java_to_cxx<jobject, joueur>(j), java_to_cxx<jobject, action>(a)));
}

jint nb_cartes(JNIEnv*, jobject, jobject j)
{
    return cxx_to_java<int, jint>(api_nb_cartes(java_to_cxx<jobject, joueur>(j)));
}

jarray cartes_en_main(JNIEnv*, jobject)
{
    return cxx_to_java_array<int, jint>(api_cartes_en_main());
}

jint carte_pioche(JNIEnv*, jobject)
{
    return cxx_to_java<int, jint>(api_carte_pioche());
}

jobject action_valider(JNIEnv*, jobject, jint c)
{
    return cxx_to_java<error, jobject>(api_action_valider(java_to_cxx<jint, int>(c)));
}

jobject action_defausser(JNIEnv*, jobject, jint c1, jint c2)
{
    return cxx_to_java<error, jobject>(api_action_defausser(java_to_cxx<jint, int>(c1), java_to_cxx<jint, int>(c2)));
}

jobject action_choix_trois(JNIEnv*, jobject, jint c1, jint c2, jint c3)
{
    return cxx_to_java<error, jobject>(api_action_choix_trois(java_to_cxx<jint, int>(c1), java_to_cxx<jint, int>(c2), java_to_cxx<jint, int>(c3)));
}

jobject action_choix_paquets(JNIEnv*, jobject, jint p1c1, jint p1c2, jint p2c1, jint p2c2)
{
    return cxx_to_java<error, jobject>(api_action_choix_paquets(java_to_cxx<jint, int>(p1c1), java_to_cxx<jint, int>(p1c2), java_to_cxx<jint, int>(p2c1), java_to_cxx<jint, int>(p2c2)));
}

jobject repondre_choix_trois(JNIEnv*, jobject, jint c)
{
    return cxx_to_java<error, jobject>(api_repondre_choix_trois(java_to_cxx<jint, int>(c)));
}

jobject repondre_choix_paquets(JNIEnv*, jobject, jint p)
{
    return cxx_to_java<error, jobject>(api_repondre_choix_paquets(java_to_cxx<jint, int>(p)));
}

void afficher_action(JNIEnv*, jobject, jobject v)
{
    (api_afficher_action(java_to_cxx<jobject, action>(v)));
}

void afficher_error(JNIEnv*, jobject, jobject v)
{
    (api_afficher_error(java_to_cxx<jobject, error>(v)));
}

void afficher_joueur(JNIEnv*, jobject, jobject v)
{
    (api_afficher_joueur(java_to_cxx<jobject, joueur>(v)));
}

void afficher_action_jouee(JNIEnv*, jobject, jobject v)
{
    (api_afficher_action_jouee(java_to_cxx<jobject, action_jouee>(v)));
}

extern "C" void init_jeu()
{
    jrt.init();
    bool attached = jrt.function_enter();
    jmethodID method = jrt.env->GetMethodID(Champion::Class(), "init_jeu", "()V");
jrt.env->CallVoidMethod(jrt.prologin, method);
    if (jrt.env->ExceptionOccurred())
    {
        jrt.env->ExceptionDescribe();
        exit(1);
    }
    jrt.function_exit(attached);
}

extern "C" void jouer_tour()
{
    jrt.init();
    bool attached = jrt.function_enter();
    jmethodID method = jrt.env->GetMethodID(Champion::Class(), "jouer_tour", "()V");
jrt.env->CallVoidMethod(jrt.prologin, method);
    if (jrt.env->ExceptionOccurred())
    {
        jrt.env->ExceptionDescribe();
        exit(1);
    }
    jrt.function_exit(attached);
}

extern "C" void repondre_action_choix_trois()
{
    jrt.init();
    bool attached = jrt.function_enter();
    jmethodID method = jrt.env->GetMethodID(Champion::Class(), "repondre_action_choix_trois", "()V");
jrt.env->CallVoidMethod(jrt.prologin, method);
    if (jrt.env->ExceptionOccurred())
    {
        jrt.env->ExceptionDescribe();
        exit(1);
    }
    jrt.function_exit(attached);
}

extern "C" void repondre_action_choix_paquets()
{
    jrt.init();
    bool attached = jrt.function_enter();
    jmethodID method = jrt.env->GetMethodID(Champion::Class(), "repondre_action_choix_paquets", "()V");
jrt.env->CallVoidMethod(jrt.prologin, method);
    if (jrt.env->ExceptionOccurred())
    {
        jrt.env->ExceptionDescribe();
        exit(1);
    }
    jrt.function_exit(attached);
}

extern "C" void fin_jeu()
{
    jrt.init();
    bool attached = jrt.function_enter();
    jmethodID method = jrt.env->GetMethodID(Champion::Class(), "fin_jeu", "()V");
jrt.env->CallVoidMethod(jrt.prologin, method);
    if (jrt.env->ExceptionOccurred())
    {
        jrt.env->ExceptionDescribe();
        exit(1);
    }
    jrt.function_exit(attached);
}

jclass Champion::Class()
{
    return jrt.env->FindClass("Champion");
}

jclass Action::Class()
{
    return jrt.env->FindClass("Action");
}

jclass Error::Class()
{
    return jrt.env->FindClass("Error");
}

jclass Joueur::Class()
{
    return jrt.env->FindClass("Joueur");
}

jclass ActionJouee::Class()
{
    return jrt.env->FindClass("ActionJouee");
}


static void _register_native_methods(JNIEnv* env)
{
    JNINativeMethod methods[] = {
        {(char*)"id_joueur", (char*)"()LJoueur;", (void*)&id_joueur},
        {(char*)"id_adversaire", (char*)"()LJoueur;", (void*)&id_adversaire},
        {(char*)"manche", (char*)"()I", (void*)&manche},
        {(char*)"tour", (char*)"()I", (void*)&tour},
        {(char*)"tour_precedent", (char*)"()LActionJouee;", (void*)&tour_precedent},
        {(char*)"nb_carte_validee", (char*)"(LJoueur;I)I", (void*)&nb_carte_validee},
        {(char*)"possession_geisha", (char*)"(I)LJoueur;", (void*)&possession_geisha},
        {(char*)"est_jouee_action", (char*)"(LJoueur;LAction;)Z", (void*)&est_jouee_action},
        {(char*)"nb_cartes", (char*)"(LJoueur;)I", (void*)&nb_cartes},
        {(char*)"cartes_en_main", (char*)"()[I", (void*)&cartes_en_main},
        {(char*)"carte_pioche", (char*)"()I", (void*)&carte_pioche},
        {(char*)"action_valider", (char*)"(I)LError;", (void*)&action_valider},
        {(char*)"action_defausser", (char*)"(II)LError;", (void*)&action_defausser},
        {(char*)"action_choix_trois", (char*)"(III)LError;", (void*)&action_choix_trois},
        {(char*)"action_choix_paquets", (char*)"(IIII)LError;", (void*)&action_choix_paquets},
        {(char*)"repondre_choix_trois", (char*)"(I)LError;", (void*)&repondre_choix_trois},
        {(char*)"repondre_choix_paquets", (char*)"(I)LError;", (void*)&repondre_choix_paquets},
        {(char*)"afficher_action", (char*)"(LAction;)V", (void*)&afficher_action},
        {(char*)"afficher_error", (char*)"(LError;)V", (void*)&afficher_error},
        {(char*)"afficher_joueur", (char*)"(LJoueur;)V", (void*)&afficher_joueur},
        {(char*)"afficher_action_jouee", (char*)"(LActionJouee;)V", (void*)&afficher_action_jouee},
    };
    env->RegisterNatives(Champion::Class(), methods, sizeof(methods)/sizeof(methods[0]));
}

StechecJavaRunTime::~StechecJavaRunTime()
{
}

void StechecJavaRunTime::init()
{
    if (is_init_)
        return;

    is_init_ = true;

    std::string classpath = "-Djava.class.path=";
    char* champion_path = getenv("CHAMPION_PATH");
    if (champion_path == NULL)
        champion_path = (char*)"./";
    classpath.append(champion_path);

    JavaVMInitArgs vm_args; /* JDK/JRE 6 VM initialization arguments */
    JavaVMOption options[4];
    options[0].optionString = (char*) classpath.c_str();
    options[1].optionString = (char*) "-ea";
    options[2].optionString = (char*) "-XX:MaxHeapSize=512m";
    options[3].optionString = (char*) "-XX:CompressedClassSpaceSize=64m";
    vm_args.version = JNI_VERSION_1_6;
    vm_args.nOptions = 4;
    vm_args.options = options;
    vm_args.ignoreUnrecognized = false;
    JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);
    prologin = env->NewObject(Champion::Class(), env->GetMethodID(Champion::Class(), "<init>", "()V"));
    _register_native_methods(env);
}

bool StechecJavaRunTime::function_enter()
{
    if (jvm->GetEnv((void**)&env, JNI_VERSION_1_6) == JNI_OK)
        return false;
    jvm->AttachCurrentThread((void**)&env, NULL);
    return true;
}

void StechecJavaRunTime::function_exit(bool attached)
{
    if (attached)
        jvm->DetachCurrentThread();
}
