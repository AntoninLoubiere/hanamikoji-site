// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2020 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the C#
// language.
// This file was generated by stechec2-generator. DO NOT EDIT.

#include <assert.h>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <vector>
#include <mono/jit/jit.h>
#include <mono/metadata/assembly.h>
#include <mono/metadata/debug-helpers.h>
#include <mono/metadata/mono-config.h>
#include <mono/metadata/threads.h>

typedef int32_t gint32;

class CSharpInterface
{
    public:
        CSharpInterface();
        ~CSharpInterface();
        MonoObject* callCSharpMethod(const char* name);
        MonoImage* getImage();
        MonoDomain* getDomain();

    private:

        MonoDomain* _domain;
        MonoAssembly* _assembly;
        MonoImage* _image;
        MonoClass* _class;
        MonoObject* _object;
};


/// Les actions de jeu
typedef enum action
{
    VALIDER, ///< Valide une unique carte
    DEFAUSSER, ///< Defausse deux cartes
    CHOIX_TROIS, ///< Donne le choix entre trois cartes
    CHOIX_PAQUETS, ///< Donne le choix entre deux paquets de deux cartes
    PREMIER_JOUEUR, ///< Aucune action n'a été jouée (utilisé dans tour_precedent)
} action;

/// Enumeration contentant toutes les erreurs possibles
typedef enum error
{
    OK, ///< pas d'erreur
    ACTION_DEJA_JOUEE, ///< l'action a déjà été jouée
    CARTES_INVALIDES, ///< vous ne pouvez pas jouer ces cartes
    PAQUET_INVALIDE, ///< ce paquet n'existe pas
    GEISHA_INVALIDES, ///< cette geisha n'existe pas (doit être un entier entre 0 et NB_GEISHA)
    JOUEUR_INVALIDE, ///< ce joueur n'existe pas
    CHOIX_INVALIDE, ///< vous ne pouvez pas repondre à ce choix
    ACTION_INVALIDE, ///< vous ne pouvez pas jouer cette action maintenant
} error;

/// Enumeration représentant les différents joueurs
typedef enum joueur
{
    JOUEUR_1, ///< Le joueur 1
    JOUEUR_2, ///< Le joueur 2
    EGALITE, ///< Égalité, utilisé uniquement dans possession_geisha
} joueur;

/// La description d'une action jouée
typedef struct action_jouee
{
    action act; ///< L'action jouée
    int c1; ///< Si act==VALIDER ou act==DEFAUSSER, -1 sinon la première carte (du premier paquet)
    int c2; ///< Si act==V|D: -1 sinon la deuxième carte (du premier paquet)
    int c3; ///< Si act==V|D: -1 sinon la troisième carte (ou la première carte du second paquet si act==choix paquet)
    int c4; ///< Si act!=choix paquet: -1 sinon la deuxième carte du second paquet
} action_jouee;

extern "C" {

/// Renvoie l'identifiant du joueur
joueur api_id_joueur();

/// Renvoie l'identifiant de l'adversaire
joueur api_id_adversaire();

/// Renvoie le numéro de la manche
int api_manche();

/// Renvoie le numéro de la manche
int api_tour();

/// Renvoie l'action jouée par l'adversaire
action_jouee api_tour_precedent();

/// Renvoie le nombre de carte validée par le joueur pour la geisha
int api_nb_carte_validee(joueur j, int g);

/// Renvoie qui possède la geisha
joueur api_possession_geisha(int g);

/// Renvoie si l'action a déjà été jouée par le joueur
bool api_est_jouee_action(joueur j, action a);

/// Renvoie le nombre de carte que le joueur a
int api_nb_cartes(joueur j);

/// Renvoie les cartes que vous avez
std::vector<int> api_cartes_en_main();

/// Renvoie la carte que vous avez pioché au début du tour
int api_carte_pioche();

/// Jouer l'action valider une carte
error api_action_valider(int c);

/// Jouer l'action défausser deux cartes
error api_action_defausser(int c1, int c2);

/// Jouer l'action choisir entre trois cartes
error api_action_choix_trois(int c1, int c2, int c3);

/// Jouer l'action choisir entre deux paquets de deux cartes
error api_action_choix_paquets(int p1c1, int p1c2, int p2c1, int p2c2);

/// Choisir une des trois cartes proposées.
error api_repondre_choix_trois(int c);

/// Choisir un des deux paquets proposés.
error api_repondre_choix_paquets(int p);

/// Affiche le contenu d'une valeur de type action
void api_afficher_action(action v);

/// Affiche le contenu d'une valeur de type error
void api_afficher_error(error v);

/// Affiche le contenu d'une valeur de type joueur
void api_afficher_joueur(joueur v);

/// Affiche le contenu d'une valeur de type action_jouee
void api_afficher_action_jouee(action_jouee v);
}

CSharpInterface gl_csharp;

// Static mapping between C++ types and mono_get_*_class.
template <typename T>
MonoClass* get_mono_class() = delete;
template <>
MonoClass* get_mono_class<int>() { return mono_get_int32_class(); };
template <>
MonoClass* get_mono_class<double>() { return mono_get_double_class(); };
template <>
MonoClass* get_mono_class<bool>() { return mono_get_boolean_class(); };
template <>
MonoClass* get_mono_class<std::string>() { return mono_get_string_class(); };

template <>
MonoClass* get_mono_class<action>()
{
    return mono_get_int32_class();
}

template <>
MonoClass* get_mono_class<error>()
{
    return mono_get_int32_class();
}

template <>
MonoClass* get_mono_class<joueur>()
{
    return mono_get_int32_class();
}

template <>
MonoClass* get_mono_class<action_jouee>()
{
    return mono_class_from_name(gl_csharp.getImage(), "Champion", "ActionJouee");
}

template <class Out, class Cxx>
Out cxx2lang(Cxx in)
{
    return (Out)in;
}

template <>
MonoString* cxx2lang<MonoString*, std::string>(std::string in)
{
    return mono_string_new(gl_csharp.getDomain(), in.c_str());
}

template <>
gint32 cxx2lang<gint32, int>(int in)
{
    return (gint32)in;
}

template <>
gint32 cxx2lang<gint32, bool>(bool in)
{
    return (gint32)in;
}

template <class Out, class Cxx>
Cxx lang2cxx(Out in)
{
    return (Cxx)in;
}

template <>
std::string lang2cxx<MonoString*, std::string>(MonoString* in)
{
    std::string s_out;
    MonoError error;
    char* c_out;

    if (!in)
        return std::string("(null)");
    c_out = mono_string_to_utf8_checked(in, &error);
    if (!mono_error_ok(&error))
    {
        s_out = std::string(mono_error_get_message(&error));
        mono_error_cleanup(&error);
        return s_out;
    }
    else
    {
        s_out = std::string(c_out);
        mono_free(c_out);
        return s_out;
    }
}

template <>
int lang2cxx<gint32, int>(gint32 in)
{
    return (int)in;
}

template <>
bool lang2cxx<gint32, bool>(gint32 in)
{
    return (bool)in;
}

template <typename CsType, typename CxxType>
MonoArray* cxx2lang_array(const std::vector<CxxType>& in)
{
    gint32 size = in.size();
    MonoClass* mcKlass = get_mono_class<CxxType>();
    MonoArray* maArray = mono_array_new(gl_csharp.getDomain(), mcKlass, size);
    for (int i = 0; i < size; ++i)
    {
        CsType item = (cxx2lang<CsType, CxxType>(in[i]));
        if constexpr (std::is_same_v<CsType, MonoObject*> ||
                      std::is_same_v<CsType, MonoString*>)
            mono_array_setref(maArray, i, item);
        else if constexpr (std::is_enum<CxxType>::value)
            mono_array_set(maArray, int, i, item);
        else
            mono_array_set(maArray, CxxType, i, item);
    }
    return maArray;
}

template <typename CsType, typename CxxType>
std::vector<CxxType> lang2cxx_array(MonoArray* in)
{
    std::vector<CxxType> out;
    gint32 size = mono_array_length(in);
    for (int i = 0; i < size; ++i)
    {
        CsType item;
        if constexpr (std::is_same_v<CsType, MonoObject*> ||
                      std::is_same_v<CsType, MonoString*>)
            item = mono_array_get(in, CsType, i);
        else
            item = mono_array_get(in, CxxType, i);
        out.push_back(lang2cxx<CsType, CxxType>(item));
    }
    return out;
}

// Les actions de jeu
template <>
gint32 cxx2lang<gint32, action>(action in)
{
    return (gint32)in;
}

template <>
action lang2cxx<gint32, action>(gint32 in)
{
    return (action)in;
}

// Enumeration contentant toutes les erreurs possibles
template <>
gint32 cxx2lang<gint32, error>(error in)
{
    return (gint32)in;
}

template <>
error lang2cxx<gint32, error>(gint32 in)
{
    return (error)in;
}

// Enumeration représentant les différents joueurs
template <>
gint32 cxx2lang<gint32, joueur>(joueur in)
{
    return (gint32)in;
}

template <>
joueur lang2cxx<gint32, joueur>(gint32 in)
{
    return (joueur)in;
}

// La description d'une action jouée

template <>
MonoObject* cxx2lang<MonoObject*, action_jouee>(action_jouee in)
{
    MonoClass* mcKlass = get_mono_class<action_jouee>();
    MonoObject* moObj = mono_object_new(gl_csharp.getDomain(), mcKlass);
    mono_runtime_object_init(moObj);
    auto arg_act = cxx2lang<gint32, action>(in.act);
    mono_field_set_value(
        moObj,
        mono_class_get_field_from_name(mcKlass, "Act"),
        &arg_act
    );
    auto arg_c1 = cxx2lang<gint32, int>(in.c1);
    mono_field_set_value(
        moObj,
        mono_class_get_field_from_name(mcKlass, "C1"),
        &arg_c1
    );
    auto arg_c2 = cxx2lang<gint32, int>(in.c2);
    mono_field_set_value(
        moObj,
        mono_class_get_field_from_name(mcKlass, "C2"),
        &arg_c2
    );
    auto arg_c3 = cxx2lang<gint32, int>(in.c3);
    mono_field_set_value(
        moObj,
        mono_class_get_field_from_name(mcKlass, "C3"),
        &arg_c3
    );
    auto arg_c4 = cxx2lang<gint32, int>(in.c4);
    mono_field_set_value(
        moObj,
        mono_class_get_field_from_name(mcKlass, "C4"),
        &arg_c4
    );
    return moObj;
}

template <>
action_jouee lang2cxx<MonoObject*, action_jouee>(MonoObject* in)
{
    action_jouee out;
    void* tmp;
    (void)tmp;
    MonoClass* mcKlass =
        mono_class_from_name(gl_csharp.getImage(), "Champion", "ActionJouee");

    mono_field_get_value(
        in,
        mono_class_get_field_from_name(mcKlass, "Act"),
        &out.act);
    mono_field_get_value(
        in,
        mono_class_get_field_from_name(mcKlass, "C1"),
        &out.c1);
    mono_field_get_value(
        in,
        mono_class_get_field_from_name(mcKlass, "C2"),
        &out.c2);
    mono_field_get_value(
        in,
        mono_class_get_field_from_name(mcKlass, "C3"),
        &out.c3);
    mono_field_get_value(
        in,
        mono_class_get_field_from_name(mcKlass, "C4"),
        &out.c4);
    return out;
}


// C# native wrapper for function id_joueur.
// Renvoie l'identifiant du joueur
gint32 cs_id_joueur()
{
    return cxx2lang<gint32, joueur>(api_id_joueur());
}

// C# native wrapper for function id_adversaire.
// Renvoie l'identifiant de l'adversaire
gint32 cs_id_adversaire()
{
    return cxx2lang<gint32, joueur>(api_id_adversaire());
}

// C# native wrapper for function manche.
// Renvoie le numéro de la manche
gint32 cs_manche()
{
    return cxx2lang<gint32, int>(api_manche());
}

// C# native wrapper for function tour.
// Renvoie le numéro de la manche
gint32 cs_tour()
{
    return cxx2lang<gint32, int>(api_tour());
}

// C# native wrapper for function tour_precedent.
// Renvoie l'action jouée par l'adversaire
MonoObject* cs_tour_precedent()
{
    return cxx2lang<MonoObject*, action_jouee>(api_tour_precedent());
}

// C# native wrapper for function nb_carte_validee.
// Renvoie le nombre de carte validée par le joueur pour la geisha
gint32 cs_nb_carte_validee(gint32 j, gint32 g)
{
    return cxx2lang<gint32, int>(api_nb_carte_validee(lang2cxx<gint32, joueur>(j), lang2cxx<gint32, int>(g)));
}

// C# native wrapper for function possession_geisha.
// Renvoie qui possède la geisha
gint32 cs_possession_geisha(gint32 g)
{
    return cxx2lang<gint32, joueur>(api_possession_geisha(lang2cxx<gint32, int>(g)));
}

// C# native wrapper for function est_jouee_action.
// Renvoie si l'action a déjà été jouée par le joueur
gint32 cs_est_jouee_action(gint32 j, gint32 a)
{
    return cxx2lang<gint32, bool>(api_est_jouee_action(lang2cxx<gint32, joueur>(j), lang2cxx<gint32, action>(a)));
}

// C# native wrapper for function nb_cartes.
// Renvoie le nombre de carte que le joueur a
gint32 cs_nb_cartes(gint32 j)
{
    return cxx2lang<gint32, int>(api_nb_cartes(lang2cxx<gint32, joueur>(j)));
}

// C# native wrapper for function cartes_en_main.
// Renvoie les cartes que vous avez
MonoArray* cs_cartes_en_main()
{
    return cxx2lang_array<gint32, int>(api_cartes_en_main());
}

// C# native wrapper for function carte_pioche.
// Renvoie la carte que vous avez pioché au début du tour
gint32 cs_carte_pioche()
{
    return cxx2lang<gint32, int>(api_carte_pioche());
}

// C# native wrapper for function action_valider.
// Jouer l'action valider une carte
gint32 cs_action_valider(gint32 c)
{
    return cxx2lang<gint32, error>(api_action_valider(lang2cxx<gint32, int>(c)));
}

// C# native wrapper for function action_defausser.
// Jouer l'action défausser deux cartes
gint32 cs_action_defausser(gint32 c1, gint32 c2)
{
    return cxx2lang<gint32, error>(api_action_defausser(lang2cxx<gint32, int>(c1), lang2cxx<gint32, int>(c2)));
}

// C# native wrapper for function action_choix_trois.
// Jouer l'action choisir entre trois cartes
gint32 cs_action_choix_trois(gint32 c1, gint32 c2, gint32 c3)
{
    return cxx2lang<gint32, error>(api_action_choix_trois(lang2cxx<gint32, int>(c1), lang2cxx<gint32, int>(c2), lang2cxx<gint32, int>(c3)));
}

// C# native wrapper for function action_choix_paquets.
// Jouer l'action choisir entre deux paquets de deux cartes
gint32 cs_action_choix_paquets(gint32 p1c1, gint32 p1c2, gint32 p2c1, gint32 p2c2)
{
    return cxx2lang<gint32, error>(api_action_choix_paquets(lang2cxx<gint32, int>(p1c1), lang2cxx<gint32, int>(p1c2), lang2cxx<gint32, int>(p2c1), lang2cxx<gint32, int>(p2c2)));
}

// C# native wrapper for function repondre_choix_trois.
// Choisir une des trois cartes proposées.
gint32 cs_repondre_choix_trois(gint32 c)
{
    return cxx2lang<gint32, error>(api_repondre_choix_trois(lang2cxx<gint32, int>(c)));
}

// C# native wrapper for function repondre_choix_paquets.
// Choisir un des deux paquets proposés.
gint32 cs_repondre_choix_paquets(gint32 p)
{
    return cxx2lang<gint32, error>(api_repondre_choix_paquets(lang2cxx<gint32, int>(p)));
}

// C# native wrapper for function afficher_action.
// Affiche le contenu d'une valeur de type action
void cs_afficher_action(gint32 v)
{
    (api_afficher_action(lang2cxx<gint32, action>(v)));
}

// C# native wrapper for function afficher_error.
// Affiche le contenu d'une valeur de type error
void cs_afficher_error(gint32 v)
{
    (api_afficher_error(lang2cxx<gint32, error>(v)));
}

// C# native wrapper for function afficher_joueur.
// Affiche le contenu d'une valeur de type joueur
void cs_afficher_joueur(gint32 v)
{
    (api_afficher_joueur(lang2cxx<gint32, joueur>(v)));
}

// C# native wrapper for function afficher_action_jouee.
// Affiche le contenu d'une valeur de type action_jouee
void cs_afficher_action_jouee(MonoObject* v)
{
    (api_afficher_action_jouee(lang2cxx<MonoObject*, action_jouee>(v)));
}

// Inititialize Mono and load the DLL file.
CSharpInterface::CSharpInterface()
{
    const char* champion_path = getenv("CHAMPION_PATH");
    std::string champion;

    if (!champion_path)
        champion = "./champion.dll";
    else
    {
        champion = champion_path;
        champion += "/champion.dll";
    }

    mono_config_parse(NULL);

    _domain = mono_jit_init(champion.c_str());
    assert(_domain != NULL);

    mono_domain_set_config(_domain, ".", ".mono.conf");

    _assembly = mono_domain_assembly_open(_domain, champion.c_str());
    assert(_assembly != NULL);

    _image = mono_assembly_get_image(_assembly);
    assert(_image != NULL);

    _class = mono_class_from_name(_image, "Champion", "Champion");
    assert(_class != NULL);

    _object = mono_object_new(_domain, _class);
    assert(_object);

    mono_runtime_object_init(_object);

    // Register API functions as internal Mono functions
    mono_add_internal_call("Champion.Api::IdJoueur", (const void*)cs_id_joueur);
    mono_add_internal_call("Champion.Api::IdAdversaire", (const void*)cs_id_adversaire);
    mono_add_internal_call("Champion.Api::Manche", (const void*)cs_manche);
    mono_add_internal_call("Champion.Api::Tour", (const void*)cs_tour);
    mono_add_internal_call("Champion.Api::TourPrecedent", (const void*)cs_tour_precedent);
    mono_add_internal_call("Champion.Api::NbCarteValidee", (const void*)cs_nb_carte_validee);
    mono_add_internal_call("Champion.Api::PossessionGeisha", (const void*)cs_possession_geisha);
    mono_add_internal_call("Champion.Api::EstJoueeAction", (const void*)cs_est_jouee_action);
    mono_add_internal_call("Champion.Api::NbCartes", (const void*)cs_nb_cartes);
    mono_add_internal_call("Champion.Api::CartesEnMain", (const void*)cs_cartes_en_main);
    mono_add_internal_call("Champion.Api::CartePioche", (const void*)cs_carte_pioche);
    mono_add_internal_call("Champion.Api::ActionValider", (const void*)cs_action_valider);
    mono_add_internal_call("Champion.Api::ActionDefausser", (const void*)cs_action_defausser);
    mono_add_internal_call("Champion.Api::ActionChoixTrois", (const void*)cs_action_choix_trois);
    mono_add_internal_call("Champion.Api::ActionChoixPaquets", (const void*)cs_action_choix_paquets);
    mono_add_internal_call("Champion.Api::RepondreChoixTrois", (const void*)cs_repondre_choix_trois);
    mono_add_internal_call("Champion.Api::RepondreChoixPaquets", (const void*)cs_repondre_choix_paquets);
    mono_add_internal_call("Champion.Api::AfficherAction", (const void*)cs_afficher_action);
    mono_add_internal_call("Champion.Api::AfficherError", (const void*)cs_afficher_error);
    mono_add_internal_call("Champion.Api::AfficherJoueur", (const void*)cs_afficher_joueur);
    mono_add_internal_call("Champion.Api::AfficherActionJouee", (const void*)cs_afficher_action_jouee);
}

MonoImage* CSharpInterface::getImage()
{
    return _image;
}

MonoDomain* CSharpInterface::getDomain()
{
    return _domain;
}

CSharpInterface::~CSharpInterface()
{
    mono_image_close(_image);
    mono_assembly_close(_assembly);
    // XXX -- mono segfaults when calling this. Seems to be a known bug
    //        appearing when mono_jit_clean() is called from a dtor. ???
    // mono_jit_cleanup(_domain);
}

// Calls C# functions from C++
MonoObject* CSharpInterface::callCSharpMethod(const char* name)
{
    MonoThread* thread = mono_thread_attach(_domain);
    MonoMethod* method = mono_class_get_method_from_name(_class, name, 0);
    MonoObject* object = mono_runtime_invoke(method, _object, NULL, NULL);

    mono_thread_detach(thread);

    return object;
}


// Functions called from Stechec to C#.

extern "C" void init_jeu()
{
    gl_csharp.callCSharpMethod("InitJeu");
}

extern "C" void jouer_tour()
{
    gl_csharp.callCSharpMethod("JouerTour");
}

extern "C" void repondre_action_choix_trois()
{
    gl_csharp.callCSharpMethod("RepondreActionChoixTrois");
}

extern "C" void repondre_action_choix_paquets()
{
    gl_csharp.callCSharpMethod("RepondreActionChoixPaquets");
}

extern "C" void fin_jeu()
{
    gl_csharp.callCSharpMethod("FinJeu");
}
